<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full-Screen Draw (SVG Save/Load)</title>
    <link rel="stylesheet" href="styles.css">
    <style>
      body { margin: 0; overflow: hidden; background: #15202B; }
      #drawingCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
      #controls { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; color: white; }
      #controls button, #controls input { margin: 5px; }
      .colorButton { width: 30px; height: 30px; border: none; cursor: pointer; }
      #helpPanel { display: none; position: absolute; top: 50px; left: 10px; background: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 5px; max-width: 400px; z-index: 10; }
      #colorButtons { display: flex; flex-wrap: wrap; gap: 5px; }
    </style>
  </head>
  <body>
    <div id="controls">
      <button onclick="DrawingModule.clearCanvas()">Clear All</button>
      <button onclick="StateModule.saveCanvas()">Save SVG</button>
      <button onclick="document.getElementById('fileInput').click()">Load SVG</button>
      <input type="file" id="fileInput" accept=".svg, image/svg+xml" style="display: none;">
      <button onclick="toggleHelp()">Help</button>
      <label>Stroke Color: <input type="color" id="colorPicker" value="#FFFFFF"></label>
      <div id="colorButtons">
        <button class="colorButton" style="background: #FFFFFF;" onclick="SettingsModule.selectColor('#FFFFFF')"></button>
        <button class="colorButton" style="background: #FF0000;" onclick="SettingsModule.selectColor('#FF0000')"></button>
        <button class="colorButton" style="background: #00FF00;" onclick="SettingsModule.selectColor('#00FF00')"></button>
        <button class="colorButton" style="background: #0000FF;" onclick="SettingsModule.selectColor('#0000FF')"></button>
        <button class="colorButton" style="background: #FFFF00;" onclick="SettingsModule.selectColor('#FFFF00')"></button>
        <button class="colorButton" style="background: #800080;" onclick="SettingsModule.selectColor('#800080')"></button>
        <button class="colorButton" style="background: #FFA500;" onclick="SettingsModule.selectColor('#FFA500')"></button>
        <button class="colorButton" style="background: #00FFFF;" onclick="SettingsModule.selectColor('#00FFFF')"></button>
        <button class="colorButton" style="background: #FF00FF;" onclick="SettingsModule.selectColor('#FF00FF')"></button>
      </div>
      <label>Background Color: <input type="color" id="backgroundColorPicker" value="#15202B"></label>
      <label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="5"></label>
      <label>Autosave Interval (s): <input type="number" id="autosaveInterval" min="1" max="60" value="10"></label>
    </div>
    <div id="helpPanel">
      <h3>Controls</h3>
      <ul>
        <li><b>Draw</b>: Left-click or use stylus.</li>
        <li><b>Erase</b>: Hold right-click to erase strokes.</li>
        <li><b>Pan</b>: Hold 'M' and drag with mouse/pen.</li>
        <li><b>Zoom</b>: Hold 'N' and drag up/down with mouse/pen.</li>
        <li><b>Undo</b>: Ctrl+Z (undoes last stroke).</li>
        <li><b>Select & Transform</b>: Hold Space to enter selection mode. Hold mouse1 to draw a rectangle and select strokes. Drag with mouse1 to move selected, drag bottom-right handle to resize selected. Release Space to exit.</li>
        <li><b>Deselect</b>: Press Esc to deselect all strokes. Selected strokes remain active after releasing Space.</li>
        <li><b>Link</b>: Press 'L' to add a hyperlink to selected strokes (prompts for URL).</li>
        <li><b>Colors</b>: Use keybinds 1-9 to select colors.</li>
        <li><b>Save SVG</b>: Click "Save SVG" to download a standard .svg file.</li>
        <li><b>Load SVG</b>: Click "Load SVG" to load a standard .svg file (resets view).</li>
        <li><b>Autosave</b>: State is saved to local storage every N seconds (configurable in controls, default 10s).</li>
      </ul>
      <button onclick="toggleHelp()">Close</button>
    </div>
    <canvas id="drawingCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
      const canvas = document.getElementById('drawingCanvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // --- Modules ---
      const SettingsModule = {
        defaultColors: ['#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#800080', '#FFA500', '#00FFFF', '#FF00FF'],
        currentStrokeColor: '#FFFFFF',
        currentStrokeLineWidth: 5,
        backgroundColor: '#15202B',
        autosaveInterval: 10, // seconds
        keybinds: {
          'm': { action: () => { DrawingModule.isMKeyPressed = true; }, release: () => { DrawingModule.isMKeyPressed = false; DrawingModule.isPanning = false; } },
          'n': { action: () => { DrawingModule.isNKeyPressed = true; }, release: () => { DrawingModule.isNKeyPressed = false; DrawingModule.isZooming = false; } },
          'l': {
            action: () => {
              const link = prompt("Link: ");
              if (link) {
                DrawingModule.strokeHistory.filter(s => s.isSelected).forEach(selected => {
                  selected.link = link;
                });
                DrawingModule.redrawCanvas();
              }
            }
          },
          ' ': {
            action: (e) => {
              e.preventDefault();
              DrawingModule.isSpacePressed = true;
              DrawingModule.isSelecting = true;
            },
            release: () => {
              DrawingModule.isSpacePressed = false;
              DrawingModule.isSelecting = false;
              DrawingModule.isDrawingSelection = false;
              if (!DrawingModule.isDragging && !DrawingModule.isResizing) DrawingModule.redrawCanvas();
            }
          },
          'Escape': {
            action: () => {
              if (DrawingModule.isDrawingSelection) {
                DrawingModule.isDrawingSelection = false;
                DrawingModule.redrawCanvas();
              } else {
                DrawingModule.strokeHistory.forEach(s => s.isSelected = false);
                DrawingModule.isDragging = false;
                DrawingModule.isResizing = false;
                DrawingModule.redrawCanvas();
              }
            }
          },
          'z': {
            action: (e) => {
              if (e.ctrlKey) {
                e.preventDefault();
                DrawingModule.undoLastStroke();
              }
            }
          },
          '1': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[0]) },
          '2': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[1]) },
          '3': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[2]) },
          '4': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[3]) },
          '5': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[4]) },
          '6': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[5]) },
          '7': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[6]) },
          '8': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[7]) },
          '9': { action: () => SettingsModule.selectColor(SettingsModule.defaultColors[8]) }
        },

        init() {
          const colorPicker = document.getElementById('colorPicker');
          const brushSize = document.getElementById('brushSize');
          const backgroundColorPicker = document.getElementById('backgroundColorPicker');
          const autosaveIntervalInput = document.getElementById('autosaveInterval');

          colorPicker.addEventListener('change', () => {
            this.currentStrokeColor = colorPicker.value;
            StateModule.saveState();
          });
          brushSize.addEventListener('input', () => {
            this.currentStrokeLineWidth = parseFloat(brushSize.value);
            StateModule.saveState();
          });
          backgroundColorPicker.addEventListener('change', () => {
            this.backgroundColor = backgroundColorPicker.value;
            DrawingModule.redrawCanvas();
            StateModule.saveState();
          });
          autosaveIntervalInput.addEventListener('change', () => {
            const newInterval = parseInt(autosaveIntervalInput.value);
            if (newInterval >= 1 && newInterval <= 60) {
              this.autosaveInterval = newInterval;
              StateModule.startAutosave();
              StateModule.saveState();
            } else {
              autosaveIntervalInput.value = this.autosaveInterval;
            }
          });

          this.currentStrokeColor = colorPicker.value;
          this.currentStrokeLineWidth = parseFloat(brushSize.value);
          this.backgroundColor = backgroundColorPicker.value;
          this.autosaveInterval = parseInt(autosaveIntervalInput.value);
        },

        selectColor(color) {
          document.getElementById('colorPicker').value = color;
          this.currentStrokeColor = color;
          StateModule.saveState();
        },

        getState() {
          return {
            currentStrokeColor: this.currentStrokeColor,
            currentStrokeLineWidth: this.currentStrokeLineWidth,
            backgroundColor: this.backgroundColor,
            autosaveInterval: this.autosaveInterval
          };
        },

        setState(state) {
          if (!state) return;
          this.currentStrokeColor = state.currentStrokeColor || '#FFFFFF';
          this.currentStrokeLineWidth = state.currentStrokeLineWidth || 5;
          this.backgroundColor = state.backgroundColor || '#15202B';
          this.autosaveInterval = state.autosaveInterval || 10;

          document.getElementById('colorPicker').value = this.currentStrokeColor;
          document.getElementById('brushSize').value = this.currentStrokeLineWidth;
          document.getElementById('backgroundColorPicker').value = this.backgroundColor;
          document.getElementById('autosaveInterval').value = this.autosaveInterval;
        }
      };

      const DrawingModule = {
        // State Variables
        isPanning: false,
        isZooming: false,
        isErasing: false,
        isSelecting: false,
        isDrawingSelection: false,
        isDragging: false,
        isResizing: false,
        isMKeyPressed: false,
        isNKeyPressed: false,
        isSpacePressed: false,
        lastPanX: 0,
        lastPanY: 0,
        offsetX: 0,
        offsetY: 0,
        scale: 1,
        minScale: 0.1,
        maxScale: 10,
        selectStartX: 0,
        selectStartY: 0,
        selectEndX: 0,
        selectEndY: 0,
        dragStartX: 0,
        dragStartY: 0,
        resizeStartBounds: null,
        HANDLE_SIZE: 20,
        HITBOX_SIZE: 30,
        ERASE_RADIUS: 15,
        isDrawing: false,
        currentStrokeCommands: [],
        currentStrokeSVG: "",
        strokeHistory: [], // { path, svgPath, color, baseLineWidth, transform, isSelected, originalBounds, link }

        init() {
          this.updateCanvasStyles();
          this.setupEventListeners();
          this.redrawCanvas();
        },

        updateCanvasStyles() {
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
        },

        setupEventListeners() {
          document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') return;
            if (SettingsModule.keybinds[e.key]) {
              SettingsModule.keybinds[e.key].action(e);
            }
            this.updateCursor();
          });

          document.addEventListener('keyup', (e) => {
              if (SettingsModule.keybinds[e.key] && SettingsModule.keybinds[e.key].release) {
                  SettingsModule.keybinds[e.key].release();
              }
              this.updateCursor();
          });

          canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            canvas.focus();
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;
            const worldX = (mouseX - this.offsetX) / this.scale;
            const worldY = (mouseY - this.offsetY) / this.scale;
            const currentSelectionBounds = this.getSelectionBounds();

            if (this.isSelecting && e.button === 0) {
              if (currentSelectionBounds && this.isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) {
                this.isResizing = true;
                this.resizeStartBounds = currentSelectionBounds;
                this.dragStartX = (this.resizeStartBounds.minX + this.resizeStartBounds.maxX) / 2;
                this.dragStartY = (this.resizeStartBounds.minY + this.resizeStartBounds.maxY) / 2;
              } else if (currentSelectionBounds && this.isPointNearSelectedStrokes(worldX, worldY)) {
                this.isDragging = true;
                this.dragStartX = worldX;
                this.dragStartY = worldY;
              } else {
                this.isDrawingSelection = true;
                this.selectStartX = mouseX;
                this.selectStartY = mouseY;
                this.selectEndX = mouseX;
                this.selectEndY = mouseY;
                this.strokeHistory.forEach(s => s.isSelected = false);
              }
            } else if (!this.isSelecting && e.button === 0 && this.strokeHistory.some(s => s.isSelected)) {
              if (currentSelectionBounds && this.isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) {
                this.isResizing = true;
                this.resizeStartBounds = currentSelectionBounds;
                this.dragStartX = (this.resizeStartBounds.minX + this.resizeStartBounds.maxX) / 2;
                this.dragStartY = (this.resizeStartBounds.minY + this.resizeStartBounds.maxY) / 2;
              } else if (currentSelectionBounds && this.isPointNearSelectedStrokes(worldX, worldY)) {
                this.isDragging = true;
                this.dragStartX = worldX;
                this.dragStartY = worldY;
              }
            }

            if (!this.isDragging && !this.isResizing && !this.isDrawingSelection) {
              if (e.button === 0 && this.isMKeyPressed) {
                this.isPanning = true;
                this.lastPanX = e.clientX;
                this.lastPanY = e.clientY;
              } else if (e.button === 0 && this.isNKeyPressed) {
                this.isZooming = true;
                this.lastPanY = e.clientY;
              } else if (e.button === 0 && !this.isSpacePressed) {
                if (!currentSelectionBounds || !this.isPointNearSelectedStrokes(worldX, worldY)) {
                  this.isDrawing = true;
                  this.currentStrokeCommands = [['M', worldX, worldY]];
                  this.currentStrokeSVG = `M ${worldX.toFixed(2)} ${worldY.toFixed(2)}`;
                  this.drawCurrentStrokeSegment();
                }
              } else if (e.button === 2) {
                this.isErasing = true;
                this.eraseStroke(worldX, worldY);
              }
            }
            this.updateCursor(mouseX, mouseY);
          });

          canvas.addEventListener('pointermove', (e) => {
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;
            const worldX = (mouseX - this.offsetX) / this.scale;
            const worldY = (mouseY - this.offsetY) / this.scale;

            if (this.isPanning) {
              const deltaX = e.clientX - this.lastPanX;
              const deltaY = e.clientY - this.lastPanY;
              this.offsetX += deltaX;
              this.offsetY += deltaY;
              this.lastPanX = e.clientX;
              this.lastPanY = e.clientY;
              this.redrawCanvas();
            } else if (this.isZooming) {
              const deltaY = e.clientY - this.lastPanY;
              const zoomFactor = 1 - deltaY * 0.005;
              const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * zoomFactor));
              const worldXBefore = (mouseX - this.offsetX) / this.scale;
              const worldYBefore = (mouseY - this.offsetY) / this.scale;
              this.scale = newScale;
              this.offsetX = mouseX - worldXBefore * this.scale;
              this.offsetY = mouseY - worldYBefore * this.scale;
              this.lastPanY = e.clientY;
              this.redrawCanvas();
            } else if (this.isDrawingSelection) {
              this.selectEndX = mouseX;
              this.selectEndY = mouseY;
              this.redrawCanvas();
            } else if (this.isDragging) {
              const deltaX = worldX - this.dragStartX;
              const deltaY = worldY - this.dragStartY;
              const translationMatrix = new DOMMatrix().translate(deltaX, deltaY);
              this.strokeHistory.forEach(strokeInfo => {
                if (strokeInfo.isSelected) strokeInfo.transform = translationMatrix.multiply(strokeInfo.transform);
              });
              this.dragStartX = worldX;
              this.dragStartY = worldY;
              this.redrawCanvas();
            } else if (this.isResizing && this.resizeStartBounds) {
              const currentCenterX = this.dragStartX;
              const currentCenterY = this.dragStartY;
              const initialHandleX = this.resizeStartBounds.maxX;
              const initialHandleY = this.resizeStartBounds.maxY;
              const distInitialX = initialHandleX - currentCenterX;
              const distInitialY = initialHandleY - currentCenterY;
              const distCurrentX = worldX - currentCenterX;
              const distCurrentY = worldY - currentCenterY;

              let scaleFactor = 1;
              if (Math.abs(distInitialX) > Math.abs(distInitialY)) {
                scaleFactor = Math.abs(distInitialX) < 1e-6 ? 1 : distCurrentX / distInitialX;
              } else {
                scaleFactor = Math.abs(distInitialY) < 1e-6 ? 1 : distCurrentY / distInitialY;
              }
              scaleFactor = Math.max(0.01, scaleFactor);

              const scaleMatrix = new DOMMatrix()
                .translate(currentCenterX, currentCenterY)
                .scale(scaleFactor)
                .translate(-currentCenterX, -currentCenterY);

              this.strokeHistory.forEach(strokeInfo => {
                if (strokeInfo.isSelected) {
                  strokeInfo.transform = scaleMatrix.multiply(strokeInfo.transform);
                }
              });

              this.resizeStartBounds = this.transformBounds(scaleMatrix, this.resizeStartBounds);
              this.redrawCanvas();
            } else if (this.isDrawing) {
              const lastCmd = this.currentStrokeCommands[this.currentStrokeCommands.length - 1];
              if (Math.hypot(worldX - lastCmd[1], worldY - lastCmd[2]) > 0.5) {
                this.currentStrokeCommands.push(['L', worldX, worldY]);
                this.currentStrokeSVG += ` L ${worldX.toFixed(2)} ${worldY.toFixed(2)}`;
                this.drawCurrentStrokeSegment();
              }
            } else if (this.isErasing) {
              this.eraseStroke(worldX, worldY);
            } else {
              this.updateCursor(mouseX, mouseY);
            }
          });

          canvas.addEventListener('pointerup', (e) => {
            if (this.isDrawing) {
              this.isDrawing = false;
              if (this.currentStrokeCommands.length > 1) {
                const finalSvgData = this.createSvgPathString(this.currentStrokeCommands);
                const newPath = new Path2D(finalSvgData);
                const bounds = this.computeBoundsFromPoints(
                  this.currentStrokeCommands.map(cmd => ({ x: cmd[1], y: cmd[2] })),
                  SettingsModule.currentStrokeLineWidth
                );
                this.strokeHistory.push({
                  path: newPath,
                  svgPath: finalSvgData,
                  color: SettingsModule.currentStrokeColor,
                  baseLineWidth: SettingsModule.currentStrokeLineWidth,
                  transform: new DOMMatrix(),
                  isSelected: false,
                  originalBounds: bounds
                });
                StateModule.saveState();
              }
              this.currentStrokeCommands = [];
              this.currentStrokeSVG = "";
              this.redrawCanvas();
            }
            if (this.isErasing) this.isErasing = false;
            if (this.isDrawingSelection) {
              this.isDrawingSelection = false;
              this.selectStrokesInRectangle();
              this.redrawCanvas();
            }
            if (this.isDragging) this.isDragging = false;
            if (this.isResizing) this.isResizing = false;
            this.isPanning = false;
            this.isZooming = false;
            this.updateCursor(e.offsetX, e.offsetY);
          });

          canvas.addEventListener('pointerleave', () => {
            if (this.isDrawing) {
              this.isDrawing = false;
              if (this.currentStrokeCommands.length > 1) {
                const finalSvgData = this.createSvgPathString(this.currentStrokeCommands);
                const newPath = new Path2D(finalSvgData);
                const bounds = this.computeBoundsFromPoints(
                  this.currentStrokeCommands.map(cmd => ({ x: cmd[1], y: cmd[2] })),
                  SettingsModule.currentStrokeLineWidth
                );
                this.strokeHistory.push({
                  path: newPath,
                  svgPath: finalSvgData,
                  color: SettingsModule.currentStrokeColor,
                  baseLineWidth: SettingsModule.currentStrokeLineWidth,
                  transform: new DOMMatrix(),
                  isSelected: false,
                  originalBounds: bounds
                });
                StateModule.saveState();
              }
              this.currentStrokeCommands = [];
              this.currentStrokeSVG = "";
              this.redrawCanvas();
            }
            this.isPanning = false;
            this.isZooming = false;
            this.isErasing = false;
            this.isDrawingSelection = false;
            this.isDragging = false;
            this.isResizing = false;
            this.updateCursor();
          });

          canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        },

        computeBoundsFromPoints(points, lineWidth) {
          if (!points || points.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
          let minX = points[0].x, maxX = points[0].x, minY = points[0].y, maxY = points[0].y;
          const margin = lineWidth / 2;
          points.forEach(p => {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y);
            maxY = Math.max(maxY, p.y);
          });
          return { minX: minX - margin, maxX: maxX + margin, minY: minY - margin, maxY: maxY + margin };
        },

        parseSvgPathToPoints(d) {
          const points = [];
          const tokens = d.match(/[MLZmlz]|[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g) || [];
          let currentX = 0, currentY = 0;

          for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (token.match(/[ML]/i)) {
              const x = parseFloat(tokens[i + 1]);
              const y = parseFloat(tokens[i + 2]);
              if (!isNaN(x) && !isNaN(y)) {
                points.push({ x, y });
                currentX = x;
                currentY = y;
                i += 2;
              }
            }
          }
          return points;
        },

        transformPoint(matrix, x, y) {
          const p = new DOMPoint(x, y);
          try {
            return matrix.transformPoint(p);
          } catch (e) {
            console.error("Matrix transformation error:", e);
            return p;
          }
        },

        transformBounds(matrix, bounds) {
          if (!bounds) return null;
          try {
            const p1 = this.transformPoint(matrix, bounds.minX, bounds.minY);
            const p2 = this.transformPoint(matrix, bounds.maxX, bounds.minY);
            const p3 = this.transformPoint(matrix, bounds.maxX, bounds.maxY);
            const p4 = this.transformPoint(matrix, bounds.minX, bounds.maxY);
            return {
              minX: Math.min(p1.x, p2.x, p3.x, p4.x),
              maxX: Math.max(p1.x, p2.x, p3.x, p4.x),
              minY: Math.min(p1.y, p2.y, p3.y, p4.y),
              maxY: Math.max(p1.y, p2.y, p3.y, p4.y)
            };
          } catch (e) {
            console.error("Error transforming bounds", e);
            return null;
          }
        },

        getSelectionBounds() {
          let overallBounds = null;
          this.strokeHistory.forEach(strokeInfo => {
            if (strokeInfo.isSelected && strokeInfo.originalBounds) {
              const currentBounds = this.transformBounds(strokeInfo.transform, strokeInfo.originalBounds);
              if (currentBounds) {
                if (!overallBounds) {
                  overallBounds = { ...currentBounds };
                } else {
                  overallBounds.minX = Math.min(overallBounds.minX, currentBounds.minX);
                  overallBounds.maxX = Math.max(overallBounds.maxX, currentBounds.maxX);
                  overallBounds.minY = Math.min(overallBounds.minY, currentBounds.minY);
                  overallBounds.maxY = Math.max(overallBounds.maxY, currentBounds.maxY);
                }
              }
            }
          });
          return overallBounds;
        },

        getDrawingBounds() {
          let overallBounds = null;
          this.strokeHistory.forEach(strokeInfo => {
            if (strokeInfo.originalBounds) {
              const currentBounds = this.transformBounds(strokeInfo.transform, strokeInfo.originalBounds);
              if (currentBounds) {
                if (!overallBounds) {
                  overallBounds = { ...currentBounds };
                } else {
                  overallBounds.minX = Math.min(overallBounds.minX, currentBounds.minX);
                  overallBounds.maxX = Math.max(overallBounds.maxX, currentBounds.maxX);
                  overallBounds.minY = Math.min(overallBounds.minY, currentBounds.minY);
                  overallBounds.maxY = Math.max(overallBounds.maxY, currentBounds.maxY);
                }
              }
            }
          });
          if (overallBounds) {
            const padding = 20;
            overallBounds.minX -= padding;
            overallBounds.minY -= padding;
            overallBounds.maxX += padding;
            overallBounds.maxY += padding;
          }
          return overallBounds;
        },

        createSvgPathString(commands) {
          const format = (num) => parseFloat(num).toFixed(2);
          return commands.map(cmd => {
            if (cmd.length === 3) return `${cmd[0]} ${format(cmd[1])} ${format(cmd[2])}`;
            return cmd.join(' ');
          }).join(' ');
        },

        drawCurrentStrokeSegment() {
          if (!this.currentStrokeSVG) return;
          const tempPath = new Path2D(this.currentStrokeSVG);
          ctx.save();
          ctx.translate(this.offsetX, this.offsetY);
          ctx.scale(this.scale, this.scale);
          ctx.strokeStyle = SettingsModule.currentStrokeColor;
          ctx.lineWidth = SettingsModule.currentStrokeLineWidth;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.stroke(tempPath);
          ctx.restore();
        },

        eraseStroke(worldX, worldY) {
          let erased = false;
          for (let i = this.strokeHistory.length - 1; i >= 0; i--) {
            const strokeInfo = this.strokeHistory[i];
            try {
              const inverseMatrix = strokeInfo.transform.inverse();
              const localPoint = this.transformPoint(inverseMatrix, worldX, worldY);
              const t = strokeInfo.transform;
              const approxScale = (Math.sqrt(t.a**2 + t.c**2) + Math.sqrt(t.b**2 + t.d**2)) / 2 || 1;
              const hitWidth = (strokeInfo.baseLineWidth / 2 + this.ERASE_RADIUS) / (this.scale * approxScale);

              ctx.lineWidth = hitWidth > 0 ? hitWidth : 0.1;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              if (ctx.isPointInStroke(strokeInfo.path, localPoint.x, localPoint.y)) {
                this.strokeHistory.splice(i, 1);
                erased = true;
              }
            } catch (error) {
              console.error("Error during erase hit test:", error);
            }
          }
          if (erased) {
            this.redrawCanvas();
            StateModule.saveState();
          }
        },

        selectStrokesInRectangle() {
          const rectMinX = Math.min(this.selectStartX, this.selectEndX);
          const rectMaxX = Math.max(this.selectStartX, this.selectEndX);
          const rectMinY = Math.min(this.selectStartY, this.selectEndY);
          const rectMaxY = Math.max(this.selectStartY, this.selectEndY);

          this.strokeHistory.forEach(strokeInfo => {
            if (strokeInfo.originalBounds) {
              const currentBounds = this.transformBounds(strokeInfo.transform, strokeInfo.originalBounds);
              if (currentBounds) {
                const screenBoundsMinX = currentBounds.minX * this.scale + this.offsetX;
                const screenBoundsMaxX = currentBounds.maxX * this.scale + this.offsetX;
                const screenBoundsMinY = currentBounds.minY * this.scale + this.offsetY;
                const screenBoundsMaxY = currentBounds.maxY * this.scale + this.offsetY;

                if (
                  screenBoundsMaxX >= rectMinX &&
                  screenBoundsMinX <= rectMaxX &&
                  screenBoundsMaxY >= rectMinY &&
                  screenBoundsMinY <= rectMaxY
                ) {
                  strokeInfo.isSelected = true;
                }
              }
            }
          });
        },

        isPointNearSelectedStrokes(worldX, worldY) {
          return this.strokeHistory.some(strokeInfo => {
            if (!strokeInfo.isSelected) return false;
            try {
              const inverseMatrix = strokeInfo.transform.inverse();
              const localPoint = this.transformPoint(inverseMatrix, worldX, worldY);
              const t = strokeInfo.transform;
              const approxScale = (Math.sqrt(t.a**2 + t.c**2) + Math.sqrt(t.b**2 + t.d**2)) / 2 || 1;
              const hitWidth = (strokeInfo.baseLineWidth / 2 + this.HITBOX_SIZE / 2) / (this.scale * approxScale);

              ctx.lineWidth = hitWidth > 0 ? hitWidth : 0.1;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              return ctx.isPointInStroke(strokeInfo.path, localPoint.x, localPoint.y);
            } catch (e) {
              console.warn("Matrix non-invertible?", e);
              return false;
            }
          });
        },

        isPointNearResizeHandle(mouseX, mouseY, selectionBounds) {
          if (!selectionBounds) return false;
          const handleScreenX = selectionBounds.maxX * this.scale + this.offsetX;
          const handleScreenY = selectionBounds.maxY * this.scale + this.offsetY;
          const dx = mouseX - handleScreenX;
          const dy = mouseY - handleScreenY;
          return Math.sqrt(dx * dx + dy * dy) < this.HITBOX_SIZE / 2;
        },

        drawSelectionRectangle() {
          if (this.isDrawingSelection) {
            ctx.save();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
              this.selectStartX,
              this.selectStartY,
              this.selectEndX - this.selectStartX,
              this.selectEndY - this.selectStartY
            );
            ctx.restore();
          }
        },

        highlightSelectedStrokes() {
          const selectionBounds = this.getSelectionBounds();
          if (selectionBounds) {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            const screenMinX = selectionBounds.minX * this.scale + this.offsetX;
            const screenMaxX = selectionBounds.maxX * this.scale + this.offsetX;
            const screenMinY = selectionBounds.minY * this.scale + this.offsetY;
            const screenMaxY = selectionBounds.maxY * this.scale + this.offsetY;
            ctx.strokeRect(screenMinX, screenMinY, screenMaxX - screenMinX, screenMaxY - screenMinY);
            ctx.restore();
          }
        },

        drawHandles() {
          const selectionBounds = this.getSelectionBounds();
          if (
            selectionBounds &&
            this.strokeHistory.some(s => s.isSelected) &&
            (!this.isSpacePressed || this.isDragging || this.isResizing)
          ) {
            ctx.save();
            const handleScreenX = selectionBounds.maxX * this.scale + this.offsetX;
            const handleScreenY = selectionBounds.maxY * this.scale + this.offsetY;
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.rect(
              handleScreenX - this.HANDLE_SIZE / 2,
              handleScreenY - this.HANDLE_SIZE / 2,
              this.HANDLE_SIZE,
              this.HANDLE_SIZE
            );
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }
        },

        updateCursor(mouseX, mouseY) {
          let cursor = 'crosshair';
          const anySelected = this.strokeHistory.some(s => s.isSelected);
          const currentSelectionBounds = anySelected ? this.getSelectionBounds() : null;

          if (
            this.isPanning ||
            (this.isMKeyPressed && !this.isDrawing && !this.isResizing && !this.isDrawingSelection)
          ) {
            cursor = 'move';
          } else if (
            this.isZooming ||
            (this.isNKeyPressed && !this.isDrawing && !this.isResizing && !this.isDrawingSelection)
          ) {
            cursor = 'ns-resize';
          } else if (this.isErasing) {
            cursor = 'crosshair';
          } else if (this.isDragging) {
            cursor = 'move';
          } else if (this.isResizing) {
            cursor = 'se-resize';
          } else if (this.isSelecting && !this.isDrawingSelection && !this.isDragging && !this.isResizing) {
            if (currentSelectionBounds && this.isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) {
              cursor = 'se-resize';
            } else if (
              currentSelectionBounds &&
              mouseX !== undefined &&
              this.isPointNearSelectedStrokes((mouseX - this.offsetX) / this.scale, (mouseY - this.offsetY) / this.scale)
            ) {
              cursor = 'move';
            } else {
              cursor = 'crosshair';
            }
          } else if (anySelected && !this.isSpacePressed && mouseX !== undefined) {
            if (currentSelectionBounds && this.isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) {
              cursor = 'se-resize';
            } else if (
              currentSelectionBounds &&
              this.isPointNearSelectedStrokes((mouseX - this.offsetX) / this.scale, (mouseY - this.offsetY) / this.scale)
            ) {
              cursor = 'move';
            }
          }
          if (canvas.style.cursor !== cursor) canvas.style.cursor = cursor;
        },

        redrawCanvas() {
          ctx.fillStyle = SettingsModule.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          this.strokeHistory.forEach(strokeInfo => {
            ctx.save();
            ctx.translate(this.offsetX, this.offsetY);
            ctx.scale(this.scale, this.scale);
            const t = strokeInfo.transform;
            ctx.transform(t.a, t.b, t.c, t.d, t.e, t.f);

            ctx.strokeStyle = strokeInfo.color;
            ctx.lineWidth = strokeInfo.baseLineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.fillStyle = 'none';

            ctx.stroke(strokeInfo.path);
            ctx.restore();
          });
          this.highlightSelectedStrokes();
          this.drawSelectionRectangle();
          this.drawHandles();
        },

        undoLastStroke() {
          if (this.strokeHistory.length > 0) {
            this.strokeHistory.pop();
            this.redrawCanvas();
            StateModule.saveState();
          }
        },

        clearCanvas() {
          this.strokeHistory = [];
          this.currentStrokeCommands = [];
          this.currentStrokeSVG = "";
          this.offsetX = 0;
          this.offsetY = 0;
          this.scale = 1;
          ctx.fillStyle = SettingsModule.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          StateModule.saveState();
        },

        getState() {
          return {
            strokeHistory: this.strokeHistory.map(stroke => ({
              svgPath: stroke.svgPath,
              color: stroke.color,
              baseLineWidth: stroke.baseLineWidth,
              transform: { a: stroke.transform.a, b: stroke.transform.b, c: stroke.transform.c, d: stroke.transform.d, e: stroke.transform.e, f: stroke.transform.f },
              isSelected: stroke.isSelected,
              originalBounds: stroke.originalBounds,
              link: stroke.link
            })),
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            scale: this.scale
          };
        },

        setState(state) {
          if (!state) return;
          this.strokeHistory = state.strokeHistory.map(stroke => {
            const path = new Path2D(stroke.svgPath);
            const transform = new DOMMatrix([
              stroke.transform.a,
              stroke.transform.b,
              stroke.transform.c,
              stroke.transform.d,
              stroke.transform.e,
              stroke.transform.f
            ]);
            return {
              path,
              svgPath: stroke.svgPath,
              color: stroke.color,
              baseLineWidth: stroke.baseLineWidth,
              transform,
              isSelected: stroke.isSelected,
              originalBounds: stroke.originalBounds,
              link: stroke.link
            };
          });
          this.offsetX = state.offsetX || 0;
          this.offsetY = state.offsetY || 0;
          this.scale = state.scale || 1;
          this.redrawCanvas();
        }
      };

      const StateModule = {
        autosaveTimer: null,

        init() {
          document.getElementById('fileInput').addEventListener('change', () => this.loadCanvas());
          this.loadStateFromStorage();
          this.startAutosave();
        },

        startAutosave() {
          if (this.autosaveTimer) clearInterval(this.autosaveTimer);
          this.autosaveTimer = setInterval(() => this.saveState(), SettingsModule.autosaveInterval * 1000);
        },

        saveState() {
          const state = {
            settings: SettingsModule.getState(),
            drawing: DrawingModule.getState()
          };
          localStorage.setItem('drawingState', JSON.stringify(state));
        },

        loadStateFromStorage() {
          const savedState = localStorage.getItem('drawingState');
          if (savedState) {
            try {
              const state = JSON.parse(savedState);
              SettingsModule.setState(state.settings);
              DrawingModule.setState(state.drawing);
            } catch (e) {
              console.error('Error loading state from storage:', e);
            }
          }
        },

        saveCanvas() {
          const bounds = DrawingModule.getDrawingBounds() || {
            minX: 0,
            minY: 0,
            maxX: canvas.width,
            maxY: canvas.height
          };
          const vbX = bounds.minX;
          const vbY = bounds.minY;
          const vbW = bounds.maxX - bounds.minX;
          const vbH = bounds.maxY - bounds.minY;

          let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vbX} ${vbY} ${vbW} ${vbH}" width="100%" height="100%">\n`;
          svgContent += `<rect x="${vbX}" y="${vbY}" width="${vbW}" height="${vbH}" fill="${SettingsModule.backgroundColor}"/>\n`;

          DrawingModule.strokeHistory.forEach(strokeInfo => {
            const t = strokeInfo.transform;
            const isIdentity =
              Math.abs(t.a - 1) < 1e-6 &&
              Math.abs(t.d - 1) < 1e-6 &&
              Math.abs(t.b) < 1e-6 &&
              Math.abs(t.c) < 1e-6 &&
              Math.abs(t.e) < 1e-6 &&
              Math.abs(t.f) < 1e-6;
            const transformAttr = isIdentity ? '' : ` transform="matrix(${t.a} ${t.b} ${t.c} ${t.d} ${t.e} ${t.f})"`;

            let path = `  <path d="${strokeInfo.svgPath}" stroke="${strokeInfo.color}" stroke-width="${strokeInfo.baseLineWidth}" stroke-linecap="round" stroke-linejoin="round" fill="none"${transformAttr} />\n`;

            if (strokeInfo.link) {
              path = `<a href="${strokeInfo.link}" target="_blank">${path}</a>\n`;
            }

            svgContent += path;
          });

          svgContent += `</svg>`;

          let filename = prompt("File name: ", "drawing") || "drawing.svg";
          if (!filename.toLowerCase().endsWith(".svg")) filename += ".svg";
          const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
          saveAs(blob, filename);
        },

        loadCanvas() {
          const file = document.getElementById('fileInput').files[0];
          if (!file) return;
          if (!file.type.startsWith('image/svg+xml') && !file.name.toLowerCase().endsWith('.svg')) {
            alert('Please select an SVG file (.svg)');
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            const svgText = e.target.result;
            try {
              const parser = new DOMParser();
              const doc = parser.parseFromString(svgText, 'image/svg+xml');

              const parserError = doc.querySelector('parsererror');
              if (parserError) throw new Error(`SVG parsing error: ${parserError.textContent}`);

              let pathElements = doc.querySelectorAll('svg > path, svg > a > path');
              if (pathElements.length === 0) {
                pathElements = doc.querySelectorAll('svg > g > path, svg > g > a > path');
              }

              // Extract background color from rect
              const rect = doc.querySelector('svg > rect');
              let backgroundColor = SettingsModule.backgroundColor;
              if (rect && rect.getAttribute('fill')) {
                backgroundColor = rect.getAttribute('fill');
              }

              DrawingModule.clearCanvas();
              SettingsModule.backgroundColor = backgroundColor;
              document.getElementById('backgroundColorPicker').value = backgroundColor;

              pathElements.forEach(pathEl => {
                const d = pathEl.getAttribute('d');
                if (!d) return;

                const path = new Path2D(d);
                const color = pathEl.getAttribute('stroke') || '#FFFFFF';
                const lineWidth = parseFloat(pathEl.getAttribute('stroke-width') || '1');

                let transform = new DOMMatrix();
                let transformAttr = pathEl.getAttribute('transform');
                if (!transformAttr && pathEl.parentNode.tagName === 'a') {
                  transformAttr = pathEl.parentNode.getAttribute('transform');
                }
                if (transformAttr) {
                  const matrixValues = transformAttr.match(/matrix\(([^)]+)\)/);
                  if (matrixValues && matrixValues[1]) {
                    const nums = matrixValues[1].split(/[\s,]+/).map(Number);
                    if (nums.length === 6 && nums.every(n => !isNaN(n))) {
                      transform = new DOMMatrix(nums);
                    }
                  }
                }

                const points = DrawingModule.parseSvgPathToPoints(d);
                const originalBounds =
                  points.length > 0
                    ? DrawingModule.computeBoundsFromPoints(points, lineWidth)
                    : { minX: 0, maxX: 0, minY: 0, maxY: 0 };

                let link = null;
                if (pathEl.parentNode.tagName === 'a') {
                  link = pathEl.parentNode.getAttribute('href') || null;
                }

                DrawingModule.strokeHistory.push({
                  path,
                  svgPath: d,
                  color,
                  baseLineWidth: lineWidth,
                  transform,
                  isSelected: false,
                  originalBounds,
                  link
                });
              });

              DrawingModule.offsetX = 0;
              DrawingModule.offsetY = 0;
              DrawingModule.scale = 1;
              DrawingModule.redrawCanvas();
              StateModule.saveState();
            } catch (err) {
              console.error('Error loading or parsing SVG:', err);
              alert(`Failed to load SVG: ${err.message}`);
              DrawingModule.clearCanvas();
            }
          };
          reader.onerror = () => {
            console.error('Error reading file:', reader.error);
            alert('Failed to read the file.');
          };
          reader.readAsText(file);
          document.getElementById('fileInput').value = '';
        }
      };

      // --- Global Functions ---
      function toggleHelp() {
        const helpPanel = document.getElementById('helpPanel');
        helpPanel.style.display = helpPanel.style.display === 'block' ? 'none' : 'block';
      }

      // --- Initialize ---
      SettingsModule.init();
      DrawingModule.init();
      StateModule.init();
    </script>
  </body>
</html>
