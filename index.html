<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full-Screen Draw (SVG Save/Load)</title>
    <link rel="stylesheet" href="styles.css">
    <style> /* Basic styles */
    </style>
  </head>
  <body>
    <div id="controls">
      <button onclick="clearCanvas()">Clear All</button>
      <button onclick="saveCanvas()">Save SVG</button>
      <button onclick="document.getElementById('fileInput').click()">Load SVG</button>
      <input type="file" id="fileInput" accept=".svg, image/svg+xml" style="display: none;">
      <button onclick="toggleHelp()">Help</button>
      <label>Color: <input type="color" id="colorPicker" value="#FFFFFF"></label>
      <div id="colorButtons">
         <button class="colorButton" style="background: #FFFFFF;" onclick="selectColor('#FFFFFF')"></button>
         <button class="colorButton" style="background: #FF0000;" onclick="selectColor('#FF0000')"></button>
         <button class="colorButton" style="background: #00FF00;" onclick="selectColor('#00FF00')"></button>
         <button class="colorButton" style="background: #0000FF;" onclick="selectColor('#0000FF')"></button>
         <button class="colorButton" style="background: #FFFF00;" onclick="selectColor('#FFFF00')"></button>
         <button class="colorButton" style="background: #800080;" onclick="selectColor('#800080')"></button>
         <button class="colorButton" style="background: #FFA500;" onclick="selectColor('#FFA500')"></button>
         <button class="colorButton" style="background: #00FFFF;" onclick="selectColor('#00FFFF')"></button>
         <button class="colorButton" style="background: #FF00FF;" onclick="selectColor('#FF00FF')"></button>
      </div>
      <label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="5"></label>
    </div>
    <div id="helpPanel">
       <h3>Controls</h3>
       <ul>
         <li><b>Draw</b>: Left-click or use stylus.</li>
         <li><b>Erase</b>: Hold right-click to erase strokes.</li>
         <li><b>Pan</b>: Hold 'M' and drag with mouse/pen.</li>
         <li><b>Zoom</b>: Hold 'N' and drag up/down with mouse/pen.</li>
         <li><b>Undo</b>: Ctrl+Z (undoes last stroke).</li>
         <li><b>Select & Transform</b>: Hold Space to enter selection mode. Hold mouse1 to draw a rectangle and select strokes. Drag with mouse1 to move selected, drag bottom-right handle to resize selected. Release Space to exit.</li>
         <li><b>Deselect</b>: Press Esc to deselect all strokes. Selected strokes remain active after releasing Space.</li>
         <li><b>Colors</b>: Use keybinds 1-9.</li>
         <li><b>Save SVG</b>: Click "Save SVG" to download a standard .svg file.</li>
         <li><b>Load SVG</b>: Click "Load SVG" to load a standard .svg file (resets view).</li>
       </ul>
       <button onclick="toggleHelp()">Close</button>
    </div>
    <canvas id="drawingCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
      const canvas = document.getElementById('drawingCanvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const colorPicker = document.getElementById('colorPicker');
      const brushSize = document.getElementById('brushSize');
      const helpPanel = document.getElementById('helpPanel');
      const fileInput = document.getElementById('fileInput');

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // --- State Variables ---
      let isPanning = false, isZooming = false, isErasing = false;
      let isSelecting = false, isDrawingSelection = false;
      let isDragging = false, isResizing = false;
      let isMKeyPressed = false, isNKeyPressed = false, isSpacePressed = false;
      let lastPanX = 0, lastPanY = 0;
      let offsetX = 0, offsetY = 0;
      let scale = 1;
      const minScale = 0.1, maxScale = 10;
      let selectStartX = 0, selectStartY = 0, selectEndX = 0, selectEndY = 0;
      let dragStartX = 0, dragStartY = 0;
      let resizeStartBounds = null;
      const HANDLE_SIZE = 20, HITBOX_SIZE = 30, ERASE_RADIUS = 15;
      const defaultColors = ['#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#800080', '#FFA500', '#00FFFF', '#FF00FF'];

      let isDrawing = false;
      let currentStrokeCommands = [];
      let currentStrokeSVG = "";
      let currentStrokeColor = '#FFFFFF';
      let currentStrokeLineWidth = 5;

      // strokeHistory stores objects:
      // { path: Path2D, svgPath: string, color: string, baseLineWidth: number,
      //   transform: DOMMatrix, isSelected: boolean, originalBounds: {minX, maxX, minY, maxY} | null }
      let strokeHistory = [];

      // --- Canvas Style Updates ---
      function updateCanvasStyles() {
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
      }
      updateCanvasStyles();

      colorPicker.addEventListener('change', () => { currentStrokeColor = colorPicker.value; });
      brushSize.addEventListener('input', () => { currentStrokeLineWidth = parseFloat(brushSize.value); });
      function selectColor(color) { colorPicker.value = color; currentStrokeColor = color; }

      // --- Bounding Box & Transformation Helpers ---
      function computeBoundsFromPoints(points, lineWidth) {
          if (!points || points.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
          let minX = points[0].x, maxX = points[0].x, minY = points[0].y, maxY = points[0].y;
          const margin = lineWidth / 2;
          points.forEach(p => {
              minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
              minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
          });
          return { minX: minX - margin, maxX: maxX + margin, minY: minY - margin, maxY: maxY + margin };
      }

      // NEW: Parse SVG path 'd' attribute to extract points
      function parseSvgPathToPoints(d) {
        const points = [];
        // Split commands (M, L, Z, etc.) while preserving numbers
        const tokens = d.match(/[MLZmlz]|[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g) || [];
        let currentX = 0, currentY = 0;

        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (token.match(/[ML]/i)) { // MoveTo or LineTo
            // Next two tokens should be x, y
            const x = parseFloat(tokens[i + 1]);
            const y = parseFloat(tokens[i + 2]);
            if (!isNaN(x) && !isNaN(y)) {
              points.push({ x, y });
              currentX = x;
              currentY = y;
              i += 2; // Skip coordinates
            }
          } else if (token.match(/[Z]/i)) { // ClosePath (optional handling)
            // No action needed for bounds
          }
          // Ignore unsupported commands (e.g., C, Q for curves) for simplicity
        }
        return points;
      }

      function transformPoint(matrix, x, y) {
          const p = new DOMPoint(x, y);
          try {
              return matrix.transformPoint(p);
          } catch (e) {
              console.error("Matrix transformation error:", e);
              return p;
          }
      }

      function transformBounds(matrix, bounds) {
          if (!bounds) return null;
          try {
            const p1 = transformPoint(matrix, bounds.minX, bounds.minY);
            const p2 = transformPoint(matrix, bounds.maxX, bounds.minY);
            const p3 = transformPoint(matrix, bounds.maxX, bounds.maxY);
            const p4 = transformPoint(matrix, bounds.minX, bounds.maxY);
            return {
                minX: Math.min(p1.x, p2.x, p3.x, p4.x),
                maxX: Math.max(p1.x, p2.x, p3.x, p4.x),
                minY: Math.min(p1.y, p2.y, p3.y, p4.y),
                maxY: Math.max(p1.y, p2.y, p3.y, p4.y),
            };
          } catch (e) {
              console.error("Error transforming bounds", e);
              return null;
          }
      }

      function getSelectionBounds() {
          let overallBounds = null;
          strokeHistory.forEach(strokeInfo => {
              if (strokeInfo.isSelected && strokeInfo.originalBounds) {
                  const currentBounds = transformBounds(strokeInfo.transform, strokeInfo.originalBounds);
                  if (currentBounds) {
                      if (!overallBounds) {
                          overallBounds = { ...currentBounds };
                      } else {
                          overallBounds.minX = Math.min(overallBounds.minX, currentBounds.minX);
                          overallBounds.maxX = Math.max(overallBounds.maxX, currentBounds.maxX);
                          overallBounds.minY = Math.min(overallBounds.minY, currentBounds.minY);
                          overallBounds.maxY = Math.max(overallBounds.maxY, currentBounds.maxY);
                      }
                  }
              }
          });
          return overallBounds;
      }

      function getDrawingBounds() {
          let overallBounds = null;
          strokeHistory.forEach(strokeInfo => {
              if (strokeInfo.originalBounds) {
                  const currentBounds = transformBounds(strokeInfo.transform, strokeInfo.originalBounds);
                  if (currentBounds) {
                      if (!overallBounds) {
                          overallBounds = { ...currentBounds };
                      } else {
                          overallBounds.minX = Math.min(overallBounds.minX, currentBounds.minX);
                          overallBounds.maxX = Math.max(overallBounds.maxX, currentBounds.maxX);
                          overallBounds.minY = Math.min(overallBounds.minY, currentBounds.minY);
                          overallBounds.maxY = Math.max(overallBounds.maxY, currentBounds.maxY);
                      }
                  }
              }
          });
          if (overallBounds) {
              const padding = 20;
              overallBounds.minX -= padding;
              overallBounds.minY -= padding;
              overallBounds.maxX += padding;
              overallBounds.maxY += padding;
          }
          return overallBounds;
      }

      function createSvgPathString(commands) {
          const format = (num) => parseFloat(num).toFixed(2);
          return commands.map(cmd => {
              if (cmd.length === 3) return `${cmd[0]} ${format(cmd[1])} ${format(cmd[2])}`;
              return cmd.join(' ');
          }).join(' ');
      }

      // --- Key Listeners ---
      document.addEventListener('keydown', (e) => {
        if (document.activeElement === colorPicker || document.activeElement === brushSize) return;

        if (e.key.toLowerCase() === 'm') isMKeyPressed = true;
        else if (e.key.toLowerCase() === 'n') isNKeyPressed = true;
        else if (e.key.toLowerCase() === 'l') {
          const link = prompt("Link: ");
          if (!link) return;
          strokeHistory.filter(s => s.isSelected).forEach(selected => {
            selected.link = link;
          });
        }
        else if (e.key === ' ') { e.preventDefault(); isSpacePressed = true; isSelecting = true; }
        else if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) { e.preventDefault(); undoLastStroke(); }
        else if (e.key >= '1' && e.key <= '9') selectColor(defaultColors[parseInt(e.key) - 1]);
        else if (e.key === 'Escape') {
          if (isDrawingSelection) {
              isDrawingSelection = false;
              redrawCanvas();
          } else {
              strokeHistory.forEach(s => s.isSelected = false);
              isDragging = false; isResizing = false;
              redrawCanvas();
          }
        }
        updateCursor();
      });

      document.addEventListener('keyup', (e) => {
        if (e.key.toLowerCase() === 'm') { isMKeyPressed = false; isPanning = false; }
        else if (e.key.toLowerCase() === 'n') { isNKeyPressed = false; isZooming = false; }
        else if (e.key === ' ') {
          isSpacePressed = false; isSelecting = false; isDrawingSelection = false;
          if (!isDragging && !isResizing) redrawCanvas();
        }
        updateCursor();
      });

      // --- Pointer Events ---
      canvas.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          canvas.focus();

          const mouseX = e.offsetX;
          const mouseY = e.offsetY;
          const worldX = (mouseX - offsetX) / scale;
          const worldY = (mouseY - offsetY) / scale;
          const currentSelectionBounds = getSelectionBounds();

          if (isSelecting && e.button === 0) {
              if (currentSelectionBounds && isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) {
                  isResizing = true;
                  resizeStartBounds = currentSelectionBounds;
                  dragStartX = (resizeStartBounds.minX + resizeStartBounds.maxX) / 2;
                  dragStartY = (resizeStartBounds.minY + resizeStartBounds.maxY) / 2;
              } else if (currentSelectionBounds && isPointNearSelectedStrokes(worldX, worldY)) {
                  isDragging = true;
                  dragStartX = worldX; dragStartY = worldY;
              } else {
                  isDrawingSelection = true;
                  selectStartX = mouseX; selectStartY = mouseY;
                  selectEndX = mouseX; selectEndY = mouseY;
                  strokeHistory.forEach(s => s.isSelected = false);
              }
          } else if (!isSelecting && e.button === 0 && strokeHistory.some(s => s.isSelected)) {
              if (currentSelectionBounds && isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) {
                  isResizing = true;
                  resizeStartBounds = currentSelectionBounds;
                  dragStartX = (resizeStartBounds.minX + resizeStartBounds.maxX) / 2;
                  dragStartY = (resizeStartBounds.minY + resizeStartBounds.maxY) / 2;
              } else if (currentSelectionBounds && isPointNearSelectedStrokes(worldX, worldY)) {
                  isDragging = true;
                  dragStartX = worldX; dragStartY = worldY;
              }
          }

          if (!isDragging && !isResizing && !isDrawingSelection) {
              if (e.button === 0 && isMKeyPressed) { isPanning = true; lastPanX = e.clientX; lastPanY = e.clientY; }
              else if (e.button === 0 && isNKeyPressed) { isZooming = true; lastPanY = e.clientY; }
              else if (e.button === 0 && !isSpacePressed) {
                  if (!currentSelectionBounds || !isPointNearSelectedStrokes(worldX, worldY)) {
                      isDrawing = true;
                      currentStrokeColor = colorPicker.value;
                      currentStrokeLineWidth = parseFloat(brushSize.value);
                      currentStrokeCommands = [['M', worldX, worldY]];
                      currentStrokeSVG = `M ${worldX.toFixed(2)} ${worldY.toFixed(2)}`;
                      drawCurrentStrokeSegment();
                  }
              } else if (e.button === 2) {
                  isErasing = true;
                  eraseStroke(worldX, worldY);
              }
          }
          updateCursor(mouseX, mouseY);
      });

      canvas.addEventListener('pointermove', (e) => {
          const mouseX = e.offsetX;
          const mouseY = e.offsetY;
          const worldX = (mouseX - offsetX) / scale;
          const worldY = (mouseY - offsetY) / scale;

          if (isPanning) {
              const deltaX = e.clientX - lastPanX, deltaY = e.clientY - lastPanY;
              offsetX += deltaX; offsetY += deltaY;
              lastPanX = e.clientX; lastPanY = e.clientY;
              redrawCanvas();
          } else if (isZooming) {
              const deltaY = e.clientY - lastPanY;
              const zoomFactor = 1 - deltaY * 0.005;
              const newScale = Math.max(minScale, Math.min(maxScale, scale * zoomFactor));
              const worldXBefore = (mouseX - offsetX) / scale;
              const worldYBefore = (mouseY - offsetY) / scale;
              scale = newScale;
              offsetX = mouseX - worldXBefore * scale;
              offsetY = mouseY - worldYBefore * scale;
              lastPanY = e.clientY;
              redrawCanvas();
          } else if (isDrawingSelection) {
              selectEndX = mouseX; selectEndY = mouseY;
              redrawCanvas();
          } else if (isDragging) {
              const deltaX = worldX - dragStartX;
              const deltaY = worldY - dragStartY;
              const translationMatrix = new DOMMatrix().translate(deltaX, deltaY);
              strokeHistory.forEach(strokeInfo => {
                  if (strokeInfo.isSelected) strokeInfo.transform = translationMatrix.multiply(strokeInfo.transform);
              });
              dragStartX = worldX; dragStartY = worldY;
              redrawCanvas();
          } else if (isResizing && resizeStartBounds) {
              const currentCenterX = dragStartX;
              const currentCenterY = dragStartY;
              const initialHandleX = resizeStartBounds.maxX;
              const initialHandleY = resizeStartBounds.maxY;
              const distInitialX = initialHandleX - currentCenterX;
              const distInitialY = initialHandleY - currentCenterY;
              const distCurrentX = worldX - currentCenterX;
              const distCurrentY = worldY - currentCenterY;

              let scaleFactor = 1;
              if (Math.abs(distInitialX) > Math.abs(distInitialY)) {
                scaleFactor = Math.abs(distInitialX) < 1e-6 ? 1 : distCurrentX / distInitialX;
              } else {
                scaleFactor = Math.abs(distInitialY) < 1e-6 ? 1 : distCurrentY / distInitialY;
              }
              scaleFactor = Math.max(0.01, scaleFactor);

              const scaleMatrix = new DOMMatrix()
                  .translate(currentCenterX, currentCenterY)
                  .scale(scaleFactor)
                  .translate(-currentCenterX, -currentCenterY);

              strokeHistory.forEach(strokeInfo => {
                  if (strokeInfo.isSelected) {
                      strokeInfo.transform = scaleMatrix.multiply(strokeInfo.transform);
                  }
              });

              resizeStartBounds = transformBounds(scaleMatrix, resizeStartBounds);
              redrawCanvas();
          } else if (isDrawing) {
              const lastCmd = currentStrokeCommands[currentStrokeCommands.length - 1];
              if (Math.hypot(worldX - lastCmd[1], worldY - lastCmd[2]) > 0.5) {
                  currentStrokeCommands.push(['L', worldX, worldY]);
                  currentStrokeSVG += ` L ${worldX.toFixed(2)} ${worldY.toFixed(2)}`;
                  drawCurrentStrokeSegment();
              }
          } else if (isErasing) {
              eraseStroke(worldX, worldY);
          } else {
              updateCursor(mouseX, mouseY);
          }
      });

      canvas.addEventListener('pointerup', (e) => {
          if (isDrawing) {
              isDrawing = false;
              if (currentStrokeCommands.length > 1) {
                  const finalSvgData = createSvgPathString(currentStrokeCommands);
                  const newPath = new Path2D(finalSvgData);
                  const bounds = computeBoundsFromPoints(currentStrokeCommands.map(cmd => ({x:cmd[1], y:cmd[2]})), currentStrokeLineWidth);
                  strokeHistory.push({
                      path: newPath, svgPath: finalSvgData, color: currentStrokeColor, baseLineWidth: currentStrokeLineWidth,
                      transform: new DOMMatrix(), isSelected: false, originalBounds: bounds
                  });
              }
              currentStrokeCommands = []; currentStrokeSVG = "";
              redrawCanvas();
          }
          if (isErasing) isErasing = false;
          if (isDrawingSelection) {
              isDrawingSelection = false;
              selectStrokesInRectangle();
              redrawCanvas();
          }
          if (isDragging) isDragging = false;
          if (isResizing) isResizing = false;
          isPanning = false; isZooming = false;
          updateCursor(e.offsetX, e.offsetY);
      });

      canvas.addEventListener('pointerleave', () => {
          if (isDrawing) {
              isDrawing = false;
              if (currentStrokeCommands.length > 1) {
                  const finalSvgData = createSvgPathString(currentStrokeCommands);
                  const newPath = new Path2D(finalSvgData);
                  const bounds = computeBoundsFromPoints(currentStrokeCommands.map(cmd => ({x:cmd[1], y:cmd[2]})), currentStrokeLineWidth);
                  strokeHistory.push({
                      path: newPath, svgPath: finalSvgData, color: currentStrokeColor, baseLineWidth: currentStrokeLineWidth,
                      transform: new DOMMatrix(), isSelected: false, originalBounds: bounds
                  });
              }
              currentStrokeCommands = []; currentStrokeSVG = "";
              redrawCanvas();
          }
          isPanning = false; isZooming = false; isErasing = false;
          isDrawingSelection = false; isDragging = false; isResizing = false;
          updateCursor();
      });

      canvas.addEventListener('contextmenu', (e) => e.preventDefault());

      // --- Helper: Draw current stroke segment ---
      function drawCurrentStrokeSegment() {
          if (!currentStrokeSVG) return;
          const tempPath = new Path2D(currentStrokeSVG);
          ctx.save();
          ctx.translate(offsetX, offsetY); ctx.scale(scale, scale);
          ctx.strokeStyle = currentStrokeColor;
          ctx.lineWidth = currentStrokeLineWidth;
          ctx.lineCap = 'round'; ctx.lineJoin = 'round';
          ctx.stroke(tempPath);
          ctx.restore();
      }

      // --- Erasing ---
      function eraseStroke(worldX, worldY) {
          let erased = false;
          for (let i = strokeHistory.length - 1; i >= 0; i--) {
              const strokeInfo = strokeHistory[i];
              try {
                  const inverseMatrix = strokeInfo.transform.inverse();
                  const localPoint = transformPoint(inverseMatrix, worldX, worldY);
                  const t = strokeInfo.transform;
                  const approxScale = (Math.sqrt(t.a**2 + t.c**2) + Math.sqrt(t.b**2 + t.d**2))/2 || 1;
                  const hitWidth = (strokeInfo.baseLineWidth / 2 + ERASE_RADIUS) / (scale * approxScale);

                  ctx.lineWidth = hitWidth > 0 ? hitWidth : 0.1;
                  ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                  if (ctx.isPointInStroke(strokeInfo.path, localPoint.x, localPoint.y)) {
                      strokeHistory.splice(i, 1);
                      erased = true;
                  }
              } catch (error) { console.error("Error during erase hit test:", error); }
          }
          if (erased) redrawCanvas();
      }

      // --- Selection ---
      function selectStrokesInRectangle() {
          const rectMinX = Math.min(selectStartX, selectEndX);
          const rectMaxX = Math.max(selectStartX, selectEndX);
          const rectMinY = Math.min(selectStartY, selectEndY);
          const rectMaxY = Math.max(selectStartY, selectEndY);

          strokeHistory.forEach(strokeInfo => {
              if (strokeInfo.originalBounds) {
                  const currentBounds = transformBounds(strokeInfo.transform, strokeInfo.originalBounds);
                  if (currentBounds) {
                      const screenBoundsMinX = currentBounds.minX * scale + offsetX;
                      const screenBoundsMaxX = currentBounds.maxX * scale + offsetX;
                      const screenBoundsMinY = currentBounds.minY * scale + offsetY;
                      const screenBoundsMaxY = currentBounds.maxY * scale + offsetY;

                      if (screenBoundsMaxX >= rectMinX && screenBoundsMinX <= rectMaxX &&
                          screenBoundsMaxY >= rectMinY && screenBoundsMinY <= rectMaxY) {
                          strokeInfo.isSelected = true;
                      }
                  }
              }
          });
      }

      function isPointNearSelectedStrokes(worldX, worldY) {
          return strokeHistory.some(strokeInfo => {
              if (!strokeInfo.isSelected) return false;
              try {
                  const inverseMatrix = strokeInfo.transform.inverse();
                  const localPoint = transformPoint(inverseMatrix, worldX, worldY);
                  const t = strokeInfo.transform;
                  const approxScale = (Math.sqrt(t.a**2 + t.c**2) + Math.sqrt(t.b**2 + t.d**2))/2 || 1;
                  const hitWidth = (strokeInfo.baseLineWidth / 2 + HITBOX_SIZE / 2) / (scale * approxScale);

                  ctx.lineWidth = hitWidth > 0 ? hitWidth : 0.1;
                  ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                  return ctx.isPointInStroke(strokeInfo.path, localPoint.x, localPoint.y);
              } catch (e) { console.warn("Matrix non-invertible?", e); return false; }
          });
      }

      function isPointNearResizeHandle(mouseX, mouseY, selectionBounds) {
          if (!selectionBounds) return false;
          const handleScreenX = selectionBounds.maxX * scale + offsetX;
          const handleScreenY = selectionBounds.maxY * scale + offsetY;
          const dx = mouseX - handleScreenX;
          const dy = mouseY - handleScreenY;
          return Math.sqrt(dx * dx + dy * dy) < HITBOX_SIZE / 2;
      }

      // --- Drawing Helpers ---
      function drawSelectionRectangle() {
        if (isDrawingSelection) {
          ctx.save();
          ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
          ctx.strokeRect(selectStartX, selectStartY, selectEndX - selectStartX, selectEndY - selectStartY);
          ctx.restore();
        }
      }

      function highlightSelectedStrokes() {
        const selectionBounds = getSelectionBounds();
        if (selectionBounds) {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
            const screenMinX = selectionBounds.minX * scale + offsetX;
            const screenMaxX = selectionBounds.maxX * scale + offsetX;
            const screenMinY = selectionBounds.minY * scale + offsetY;
            const screenMaxY = selectionBounds.maxY * scale + offsetY;
            ctx.strokeRect(screenMinX, screenMinY, screenMaxX - screenMinX, screenMaxY - screenMinY);
            ctx.restore();
        }
      }

      function drawHandles() {
        const selectionBounds = getSelectionBounds();
        if (selectionBounds && strokeHistory.some(s => s.isSelected) && (!isSpacePressed || isDragging || isResizing)) {
          ctx.save();
          const handleScreenX = selectionBounds.maxX * scale + offsetX;
          const handleScreenY = selectionBounds.maxY * scale + offsetY;
          ctx.fillStyle = '#FFF'; ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.rect(handleScreenX - HANDLE_SIZE / 2, handleScreenY - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
          ctx.fill(); ctx.stroke();
          ctx.restore();
        }
      }

      function updateCursor(mouseX, mouseY) {
          let cursor = 'crosshair';
          const anySelected = strokeHistory.some(s => s.isSelected);
          const currentSelectionBounds = anySelected ? getSelectionBounds() : null;

          if (isPanning || (isMKeyPressed && !isDrawing && !isResizing && !isDragging && !isDrawingSelection)) cursor = 'move';
          else if (isZooming || (isNKeyPressed && !isDrawing && !isResizing && !isDragging && !isDrawingSelection)) cursor = 'ns-resize';
          else if (isErasing) cursor = 'crosshair';
          else if (isDragging) cursor = 'move';
          else if (isResizing) cursor = 'se-resize';
          else if (isSelecting && !isDrawingSelection && !isDragging && !isResizing) {
              if (currentSelectionBounds && isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) cursor = 'se-resize';
              else if (currentSelectionBounds && mouseX !== undefined && isPointNearSelectedStrokes((mouseX - offsetX) / scale, (mouseY - offsetY) / scale)) cursor = 'move';
              else cursor = 'crosshair';
          } else if (anySelected && !isSpacePressed && mouseX !== undefined) {
              if (currentSelectionBounds && isPointNearResizeHandle(mouseX, mouseY, currentSelectionBounds)) cursor = 'se-resize';
              else if (currentSelectionBounds && isPointNearSelectedStrokes((mouseX - offsetX) / scale, (mouseY - offsetY) / scale)) cursor = 'move';
          }
          if (canvas.style.cursor !== cursor) canvas.style.cursor = cursor;
      }

      // --- Core Drawing Function ---
      function redrawCanvas() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          strokeHistory.forEach(strokeInfo => {
              ctx.save();
              ctx.translate(offsetX, offsetY); ctx.scale(scale, scale);
              const t = strokeInfo.transform;
              ctx.transform(t.a, t.b, t.c, t.d, t.e, t.f);

              ctx.strokeStyle = strokeInfo.color;
              ctx.lineWidth = strokeInfo.baseLineWidth;
              ctx.lineCap = 'round'; ctx.lineJoin = 'round';
              ctx.fillStyle = 'none';

              ctx.stroke(strokeInfo.path);
              ctx.restore();
          });
          highlightSelectedStrokes();
          drawSelectionRectangle();
          drawHandles();
      }

      // --- Actions ---
      function undoLastStroke() {
        if (strokeHistory.length > 0) {
          strokeHistory.pop();
          redrawCanvas();
        }
      }

      function clearCanvas() {
        strokeHistory = [];
        currentStrokeCommands = []; currentStrokeSVG = "";
        offsetX = 0; offsetY = 0; scale = 1;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      // --- SVG Save/Load ---
      function saveCanvas() {
          const bounds = getDrawingBounds() || { minX: 0, minY: 0, maxX: canvas.width, maxY: canvas.height };
          const vbX = bounds.minX;
          const vbY = bounds.minY;
          const vbW = bounds.maxX;
          const vbH = bounds.maxY;
          const backgroundColor = "#15202B";

          let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vbX} ${vbY} ${vbW} ${vbH}" width="100%" height="100%">\n
<rect x="0" y="0" width="100%" height="100%" fill="${backgroundColor}"/>
`;

          strokeHistory.forEach(strokeInfo => {
              const t = strokeInfo.transform;
              const isIdentity = Math.abs(t.a - 1) < 1e-6 && Math.abs(t.d - 1) < 1e-6 &&
                                 Math.abs(t.b) < 1e-6 && Math.abs(t.c) < 1e-6 &&
                                 Math.abs(t.e) < 1e-6 && Math.abs(t.f) < 1e-6;
              const transformAttr = isIdentity ? '' : ` transform="matrix(${t.a} ${t.b} ${t.c} ${t.d} ${t.e} ${t.f})"`;

              let path = `  <path d="${strokeInfo.svgPath}" stroke="${strokeInfo.color}" stroke-width="${strokeInfo.baseLineWidth}" stroke-linecap="round" stroke-linejoin="round" fill="none"${transformAttr} />\n`;

              if (strokeInfo.link) {
                path = `<a href="${strokeInfo.link}" target="_blank">${path}</a>\n`;
              }

              svgContent += path;
          });

          svgContent += `</svg>`;

          let filename = prompt("File name: ", "drawing") || "drawing.svg";
          if (!filename.toLowerCase().endsWith(".svg")) {
              filename += ".svg";
          }
          const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
          saveAs(blob, filename);
      }

      function loadCanvas() {
          const file = fileInput.files[0];
          if (!file) return;
          if (!file.type.startsWith('image/svg+xml') && !file.name.toLowerCase().endsWith('.svg')) {
              alert('Please select an SVG file (.svg)');
              return;
          }

          const reader = new FileReader();
          reader.onload = function(e) {
              const svgText = e.target.result;
              try {
                  const parser = new DOMParser();
                  const doc = parser.parseFromString(svgText, 'image/svg+xml');

                  const parserError = doc.querySelector('parsererror');
                  if (parserError) {
                      throw new Error(`SVG parsing error: ${parserError.textContent}`);
                  }

                  let pathElements = doc.querySelectorAll('svg > path');
                  if (pathElements.length === 0) {
                      pathElements = doc.querySelectorAll('svg > g > path');
                  }

                  clearCanvas();

                  pathElements.forEach(pathEl => {
                      console.log("Loading path", pathEl);
                      const d = pathEl.getAttribute('d');
                      if (!d) return;

                      const path = new Path2D(d);
                      const color = pathEl.getAttribute('stroke') || '#FFFFFF';
                      const lineWidth = parseFloat(pathEl.getAttribute('stroke-width') || '1');

                      let transform = new DOMMatrix();
                      const transformAttr = pathEl.getAttribute('transform');
                      if (transformAttr) {
                          const matrixValues = transformAttr.match(/matrix\(([^)]+)\)/);
                          if (matrixValues && matrixValues[1]) {
                              const nums = matrixValues[1].split(/[\s,]+/).map(Number);
                              if (nums.length === 6 && nums.every(n => !isNaN(n))) {
                                  transform = new DOMMatrix(nums);
                              } else {
                                  console.warn("Could not parse transform matrix:", transformAttr);
                              }
                          } else {
                              console.warn("Unsupported transform format:", transformAttr);
                          }
                      }

                      // Compute originalBounds from SVG path
                      const points = parseSvgPathToPoints(d);
                      const originalBounds = points.length > 0
                          ? computeBoundsFromPoints(points, lineWidth)
                          : { minX: 0, maxX: 0, minY: 0, maxY: 0 }; // Fallback for empty paths

                      strokeHistory.push({
                          path: path,
                          svgPath: d,
                          color: color,
                          baseLineWidth: lineWidth,
                          transform: transform,
                          isSelected: false,
                          originalBounds: originalBounds
                      });
                  });

                  offsetX = 0; offsetY = 0; scale = 1;
                  redrawCanvas();

              } catch (err) {
                  console.error('Error loading or parsing SVG:', err);
                  alert(`Failed to load SVG: ${err.message}`);
                  clearCanvas();
              }
          };
          reader.onerror = function() {
              console.error('Error reading file:', reader.error);
              alert('Failed to read the file.');
          };
          reader.readAsText(file);
          fileInput.value = '';
      }

      fileInput.addEventListener('change', loadCanvas);

      function toggleHelp() {
        helpPanel.style.display = helpPanel.style.display === 'block' ? 'none' : 'block';
      }

      // Initial Draw
      redrawCanvas();
    </script>
  </body>
</html>
